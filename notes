Utiliser un pointer : 

int *pNumber = nullptr; //ou int *pNumber = {nullptr}; permet de pointer sur null

pNumber = {new int(77)}; //allocation dynamique dans le heap ( mémoire disponible pour le programme et non utilisé)

// ou bien on ecrit dans la mémoire allouée la valeur : *pNumber = 77;

/////// style classique pour créer pointer
int number = 88;     // An int variable with a value
int * pNumber;       // Declare a pointer variable called pNumber pointing to an int (or int pointer)
pNumber = &number;
///////

//check for null value
if(pNumber != nullptr){
   std::cout << "*pNumber : " << *pNumber << std::endl;
}
else {
   std::cout << "Ivalid adress" << std::endl;
}

...

delete pNumber; // supression et on rend mémoire à l'os

pNumber = nullptr; // bonne pratique de le faire pointer sur null, améliore la sécurité


****************************************************************
Class
Voir rpgCorrections pour l'organisation fichiers.

int main() {

   Cylinder cylinder1(10,10);

   cylinder1.volume();

   // Managing a stack object through pointers (contient juste l'adresse, pas l'objet contruit)
   Cylinder *p_cylinder1 = &cylinder1

   // Acces à une methode de l'objet de 2 manieres possible, la 2eme à privilégier :
   cout << "Volume : " << (*p_cylinder1).volume(); << endl;
   cout << "Volume : " << p_cylinder1->volume(); << endl;

   // Create cylinder heap objet through the new operator (contient une nouvelle adresse avec création d'objet)
   Cylinder *p_cylinder2 = new Cylinder(100,2); // Comme s'est créee sur le heap ne pas oublier de le supprimer

   cout << "Volume cylinder2: " << p_cylinder2->volume(); << endl;

   // Ne pas oublier de toujours supprimer le pointeur afin de libérer l'adresse
   delete p_cylinder2;
   p_cylinder2 = nullptr;
}

class syntax :
dog.h :
#ifndef DOG_H
#define DOG_H

class Dog
{
   public:
      Dog();
      Dog(string name_param, string breed_param, int age_param);
      ~Dog(); //Destructor déclaré
            //Can also declare and implement in here:
      ~Dog()
         {
            delete dog_age;
            cout << "Dog destructor called for " << dog_name << endl; 
         }

      ...

      private:
         string dog_name;
         string dog_breed;
         int *dog_age{nullptr};   
}
#endif

dog.cpp :
#include "dog.h"

Dog::Dog() {
   dog_name = "None";
   dog_breed = "None";
   dog_age = new int; // Dynamic memory allocation
   *dog_age = 0;
}

Dog::Dog(string name_param, string breed_param, int age_param) {
   dog_name = name_param;
   dog_breed = breed_param;
   dog_age = new int; // Memory allocated on the heap
   *dog_age = age_param;
}
 Dog::~Dog()
      {
         delete dog_age; // Release memory
         cout << "Dog destructor called for " << dog_name << endl; 
      }


****************************************************************
Default arguments and virtual function in C++

#include<iostream>
using namespace std;
class B {
   public:
      virtual void s(int a = 0) {
         cout<<" In Base \n";
      }
};
class D: public B {
   public:
      virtual void s(int a) {
         cout<<"In Derived, a="<<a;
      }
};
int main(void) {
   D d; // An object of class D
   B *b= &d;// A pointer of type B* pointing to d
   b->s();// prints"D::s() called"
   return 0;
